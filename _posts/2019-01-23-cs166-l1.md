---
layout: single
title: "CS 166 Lecture 1: Range Minimum Queries, Part 1"
permalink: /posts/cs166-l1/
categories: course-notes
mathjax: true
classes: wide
gallery:
  - url: /assets/images/cs166-l1-2.png
  	image_path: /assets/images/cs166-l1-2.png
  - url: /assets/images/cs166-l1-3.png
  	image_path: /assets/images/cs166-l1-3.png

---

*CS 166: Data Structures, created and taught by Keith Schwarz, delves deep into data structures and teaches powerful associated concepts and techniques. It gives a taste of this exciting area of theoretical computer science, and goes into some advanced material. The description of the course is [here][description] and the course website is [here][website]. This post covers the first lecture, Range Minimum Queries (Part 1), for which the slides can be found [here][slides].*

This lecture introduces the Range Minimum Query problem, abbreviated RMQ. This turns out to be a great way to start off the course since the RMQ problem involves a number of interesting (and beautiful!) concepts and techniques. The statement of the problem, taken from the lecture slides, is the following: given an array $A$ and two indices $i \leq j$, what is the smallest element out of $A[i], A[i+1], \dots, A[j-1], A[j]$? The image below, from the slides, shows an example query for which $26$ is the answer. We will denote an RMQ on $A$ from $i$ to $j$, inclusive, by $RMQ_A(i,j)$. Note that we will use $0$-indexing when we talk about array indices.

![RMQ example](/assets/images/cs166-l1-1.png)

Of course, the trivial solution is to iterate across the given range and take the minimum. But if we are given a fixed array $A$ and we expect many different queries on it - a typical situation in real-world settings - this solution would be very slow since each query would take $O(n)$ time.

In these situations, where we have a fixed piece of data and we want to support many queries on it efficiently, it's natural to consider some form of preprocessing. We can start by considering the simplest form of preprocessing: just precompute all possible RMQs! How many are there? Given an array $A$ of length $n$, there are

* $n$ possible queries of length $1$ ($RMQ_A(i,i) \forall i \in \{1, \dots, n\}$),
* $n-1$ possible queries of length $2$ ($RMQ_A(i,i+1) \forall i \in \{1, \dots, n - 1\}$),

  $\vdots$

* $2$ possible queries of length $n-1$ ($RMQ_A(0,n-1)$ and $RMQ_A(1,n)$), and
* $1$ possible query of length $n$ ($RMQ_A(0,n)$).

The following two screenshots, from the slides, demonstrate this visually.

{% include gallery class="full" %}

So in total, we have $1 + 2 + \dots + (n - 1) + n = \frac{n}{2}(n+1) = \Theta(n^2)$ possible RMQs. If we precompute all of them, we can answer any query in $O(1)$ time. The preprocessing cost, however, is clearly too expensive. Computing each range takes $O(n)$ time, and since we have $\Theta(n^2)$ ranges, the preprocessing time complexity is $O(n^3)$. A simple argument, based on examining a subset of ranges that are long enough, shows that it is also $\Theta(n^3)$.




[description]: https://explorecourses.stanford.edu/search?view=catalog&filter-coursestatus-Active=on&page=0&catalog=&academicYear=&q=cs166&collapse=
[website]: http://web.stanford.edu/class/cs166/
[slides]: http://web.stanford.edu/class/cs166/lectures/00/Slides00.pdf
